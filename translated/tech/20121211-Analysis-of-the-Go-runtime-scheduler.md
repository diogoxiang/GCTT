# Go 运行时调度器（runtime scheduler）分析

## 摘要

Go runtime，以及最近改进它的建议，都来自于先前改善其可扩展性和性能的工作。在本篇论文中，我们会探索一些之前的研究，一部分对 Go runtime 有着深远的影响，而一部分被作为设计 Go runtime 的指导准则。另外，基于抢占式的调度技术，他们也提出了一些对于 runtime 的额外扩展。

## 1. 序言

Go 语言是用的计算模型是基于 C.A.R. Hoare 于 1978[10]. 年发表的一篇关于**Communicating Sequential Processes**的重要论文。Go 是一种高级语言，应用了 Hoare 的论文中提出了许多架构，这在 C 语言家族中没有发现，而且比锁和信号保护共享内存更容易推理。Go 提供了通过 Goroutines 来支持并发，不仅如此，goroutines 相比于线程，更加轻量级，并且可以独立运行。goroutine 相互之间通过一个叫做 channel 的结构来通信，而 channel 本质上是一个**同步消息队列**。channels 通信，加上对 Go 对闭包一流的支持，可以让我们通过一种直接方式，解决复杂的问题。

Go 第一个稳定的版本最近发布了，它仍然在开发当中，并且还有很多改进，特别是它的编译器和基础架构。另外还有 Hoare 和他所提出的先于 Go 诞生的 CSP 语言，都对于 Go 提供了巨大的贡献。在我们的研究过程中，我们参考了许多论文，这些论文在 Go 的实现上有一些共同点，也有一些论文在算法的细节上和解决方案上可以很好的应用在 GO 上。基于这些研究，我们提出了一个 Go runtime 的拓展，我们相信这可以改善当前 Dmity Vyukov 的 Go runtime 的实现。

在这篇论文中，我们主要探索一下 Go 的 runtime 调度器。我们对 Go runtime 调度器特别感兴趣是因为我们相信一个相对比较小的改动就可以导致很大的性能提升。这篇论文贡献有，Go runtime 调度器的分析，Go runtime 相关研究的总览以及对调度器的一些改进意见。

章节 2 是 Go 语言历史的简述。章节 3 我们探索一下 Go runtime 调度器的实现，在章节 4 谈论一下当前实现的局限性。章节 5 我们描述了对于调度器的改进意见及细节。章节 6 描述了数篇应用在 Go runtime 的论文。章节 7 我们讨论一些坚持使用的好的 ideas，并且章节 8 我们提出了 Go runtime 扩展的改进意见。章节 9 总结全文。

## 2. Go 语言简史

Hoare 的名为 "Communicating Sequential Processes" 的论文，发表于单机多处理器流行之前。许多研究者，包括 Hoare 在内的许多研究人员都看到了这一趋势的前兆，并且解决了在多核处理器无处不在之前需要回答的研究问题。Hoare 看见了多处理器下进程之间存在的潜在问题。当时的通信模型和今天的线程通信模型有着许多相同的原语。即，在锁机制的协助下来修改共享内存。这个模型很难进行推断，并且容易产生 bug 和错误。Hoare 提出来的解决方案包含了一系列的原语来进程之间消息的传递，而不是修改共享呢内存。

Go 语言里用到的许多原语都可以在 Hoare 的 CSP 论文中找到出处。例如，Goroutine，channel 通信以及 select 表达式。这片关于 CSP 的论文详述了许多常见的计算机科学和逻辑问题，也包括这些问题的解决方案。论文中讨论的问题包括计算因子，有界缓冲，哲学家就餐及矩阵乘法等经典问题。尽管 Hoare 使用的符号有很大的不同，但是解决方案的实现和 Go 是基本相同的。当时，Hoare 的 CSP 原语是纯理论化的，但是现在技术已经发展了，我们可以看到他对于并行处理的观点在今日仍然非常有价值。

在贝尔实验室开发的基于 CSP 的语言中，Newsqueak 是杰出的一个，并且对 Go 语言影响深远。Rob Pike 从事过好几个这些语言的开发，并且 Newsqueak 是第一个有 channel。这样 channel 和函数的优雅组合可以开发出复杂的通信结构。对于 Newsqueak 语言及其继任者，例如 Alef 和 Limbo，提供了许多语言进化的令人迷人的视角，可以让我们去追溯 Go 的优雅结构的历史。

## 3. Go Runtime 论述

Go Runtime 管理调度，垃圾收集和 Goroutines 的运行时环境等等。我们主要关注调度器，但是为了做到这一点，也会对 runtime 作基本了解。首先，我们将讨论 runtime 是什么，特别是在与底层操作系统以及程序员编写的 Go 代码有关的情况下。

Go 程序被 Go 编译器编译成机器码。由于 Go 提供了诸如 Goroutine，channel 和垃圾收集等高层次的构造，所以需要运行时基础结构来支持这些特性。runtime 是在链接阶段静态链接到已编译的用户代码的 C 代码。因此，Go 程序在操作系统的用户空间中显示为独立的可执行文件。尽管如此，我们可以将 God 的执行程序想象为由两个离散的层组成：用户代码层和 runtime 层，他们通过函数调用来管理 Goroutines，channels 以及其他一些高层次的结构。用户代码对操作系统 API 的所有调用都要通过 runtime 层，来方便调度，当然也包括垃圾回收。图 1 展示了 Go 程序，Go runtime 以及底层操作系统之间的关系

![屏幕快照 2017-12-18 下午 4.12.49](/Users/coyote/Desktop/ 屏幕快照 2017-12-18 下午 4.12.49.png)

**图 1：runtime, os 和用户代码之间的关系**

可以说，Go runtime 最重要的一个方面就是 Goroutine 的调度器。runtime 追踪每一个 Goroutine，并且在线程池中调度它们。goroutine 是运行在线程之上的，并且有效的在线程之上调度 Goroutine 对于 Go 程序的性能来说至关重要。goroutine 可以并行运行，就像线程一样，但是相比较于线程，goroutine 是更加轻量级的。所以一个 Go 可能会创建很多线程，而 Goroutine 的数量又会比线程的要多的多。之所以需要多个线程是因为要保证 Goroutine 阻塞。当一个 Goroutine 进行阻塞调用时，运行它的线程也必须阻塞。所以，runtime 至少要创建一个以上的线程来继续执行其他没有阻塞的 Goroutine。通过设置 GOMAXPROCS[6]，开发可以定义线程的最大数量。

goroutine 对于操作系统来说是透明的，操作系统并不知道 Goroutine 的存在，对操作系统来讲仅仅是用户进程及其线程。

在 Go runtime 里面，主要有三个 C 数据结构来支持 Goroutine 的调度，以及追踪和保存所有的状态信息。

### G

G 代表一个 Goroutine[9]。它保存有其堆栈和当前状态的字段。当然也有运行其代码的引用。见下图

![屏幕快照 2017-12-25 下午 10.28.44](/Users/coyote/Desktop/ 屏幕快照 2017-12-25 下午 10.28.44.png)

**图片 2：G 的相关字段**

### M

M 是 Go runtime 对于线程的表示[9]。它有志向全局 G 队列的指针，当前运行的 G，自己的 cache 以及调度器的句柄。见下图 ![屏幕快照 2017-12-25 下午 10.29.35](/Users/coyote/Desktop/ 屏幕快照 2017-12-25 下午 10.29.35.png)

### SCHED

Sched 是一个唯一的，全局的数据结构[9]。它保存有不同 G 和 M 队列，以及一些其他的调度器的信息，例如全局的 Sched 锁。另外还有两个 G 队列，一个是 M 可以拿去运行的 G 队列，另外一个是 G 的空闲队列。Sched 里有一个 M 队列，在这个队列里的 M 是空闲的并且随时准备工作。为了修改这些队列，一个全局的 Sched 的锁是必要的。如下图

![屏幕快照 2017-12-25 下午 10.47.12](/Users/coyote/Desktop/ 屏幕快照 2017-12-25 下午 10.47.12.png)

Runtime 开始运行时也会运行多个 G。一个用来管理垃圾回收，一个负责调度，还有一个代表着用的 Go 代码。开始时，一个 M 被创建出来并且唤醒 runtime。随着程序运行，许许多多的 G 会被用户 G 程序创建，所以就许多更多的 M 来运行所有的 G。这时，runtime 可能需要提供额外的线程 ( 取决于 GOMAXPROCS)。因为在任何时候，go 程序最多有 GOMAXPROCS 个活动的 M。

因为 M 代表着线程，所以 M 需要来运行 Goroutine。一个空闲的 M 会从全局可运行 G 队列中拿出一个 G 并且运行它。如果 G 需要运行它的 M 阻塞，比如系统调用，那么其他的 M 就会从全局空闲 M 中唤醒。这样做是为了保证 Goroutines 仍然可以运行，而不是因为缺少可运行的 M 而阻塞。

系统调用强制调用线程陷入内核，导致它在系统调用执行期间被阻塞。如果与 G 相关的代码进入系统调用，运行它的 M 就不可能再运行其他 G，直到系统调用返回。但是 channel 通信中，M 并不会出现同样的阻塞。操作系统并不知道 channel 通信，channels 的细节完全被 runtime 所掌控，对操作系统透明。如果一个 Goroutine 有一个 channel 调用，它会阻塞，但是运行它的 M 是不会阻塞的。这种情况下，G 的状态会被设置成 waitting，并且运行它 M 会运行其他的 G 直到 channel 调用返回。这时 G 的状态被重新设置为 runnable，并且尽快被 M 运行。

## 4. 改进

当前的 runtime 调度器是相对简单的。go 本身是年轻的，所以这意味着还没有足够的时间去优化它的实现。当前的调度器可以运行，但是却会导致一些性能问题。Dmitry Vyukov 在他的设计文档里提出了当前调度器的主要问题，并且也提出了改进调度器的建议。

一个问题是调度器过度依赖于全局的 Sched 锁。为了安全的修改 M 队列和 G 队列，以及其他的一些全局变量，这个锁是必须的。但是在我们构建大型系统的时候，这就导致了一些新的问题，特别是 " 高吞吐量和并行计算程序 "。

更大问题在于 M 数据结构。即使一个 M 没有执行 Go 代码，也必须需要一个超过 2MB 的 MCache，这是没有必要的，特别是它没有运行一个 Goroutine。如果空闲 M 的数量变得太多，就会导致严重的性能问题以及 "poor data locality"[13]。第三个问题是系统调用会导致多余的对于 M 的锁和解锁操作，特别浪费 CPU 时间。最后，当前的设计会导致 M 将 G 互相传递，而不是运行 G，这也会导致不必要的延迟和资源开支。

## 5. VYUKOV 的的改进建议

Dmitry Vyukov 是 Google 的一名员工。他发布了一份详细介绍当前运行时间调度程序的一些缺陷的文档，并概述了 Go 的运行时调度程序的未来改进[13]。本章节也包括他提出的改进意见的总结。

Vyukov 的计划中，有一个是创建一个抽象层。他提出另外一个数据结构 P，来模拟处理器。M 仍然代表 OS 线程，G 仍然用来标会 Goroutine。用 GOMAXPROCS 来表示 P 的数量，M 会需要 P 作为资源，才能运行 Go code。

P 会偷走许多原来 M 和 Sched 的字段。例如，MCache 移动到了 P 中，并且每一个 P 会有一个本地可运行 G 队列而不是一个全局的队列。在 P 中建立本地队列，可以解决之前 Sched 全局锁的问题，并且将 cache 中 M 移到 P 中，减少空间的浪费。无论何时一个 G 被创建出来，它就会被放到 P 的队尾，来保证这个 G 最终会被执行到。另外，在 P 的顶层实现了工作窃取算法。当一个 P 的 G 队列为空时，它会随机的选择其他 P 的队尾并偷走一半的 G 给自己。如果要运行一个 G，如果在搜索 G 运行时，M 遇到了一个锁定到空闲 M 的 G，它将唤醒空闲的 M，并将其关联的 G 和 P 交给先前闲置的 M。

另外的问题是 Vyukov 提出的 M 连续的阻塞和解阻塞的问题，导致了很多资源开销。Vyukov 想要运用空转来代替锁，以减少资源开销。它提出了两种空转[13]:

1. 一个空闲的，有 P 的 M 空转，不断寻找新的 G
2. 没有 P 的 M 空转等待可用的 P

在任何时候，最多有 GOMAXPROCS 空转的 M。

而且，任何一个拥有 P 的空闲 M 不能阻塞，当有空闲的 M 没有 P 的时候。有三种情况可以导致 M 暂时不能运行 G 代码。当一个 G 产生时，M 进入系统调用或 M 从空闲转为忙的时候。在变成阻塞状态前，M 必须首先保证至少有一个自旋的 M，除非所有 P 是忙的。这就可以解决连续的 blocking 和 unblocking 导致的问题，并且保证了只要有 G 可以运行，每一个 P 当前都有一个运行的 G。所以，通过运行自旋机制，系统调用导致的开销也相对的减少了。

Vyukov 同样建议，除非真的需要，不要将 G 和栈空间分配给一个新的 Goroutine。他指出我们仅需要 6 个字就能创建一个 Goroutine 而不用调用函数或分配内存。这样会大幅度减少内存的开销。另一个改进建议是将 G 的局部性到 P，因为 G 上次运行的 P 将已经使其 MCache 载入。类似的，G 的局部性在 M 中也是有益的，会让 G 可以更容易的运行。我们必须记住 P 是一个 runtime 创建起来的抽象概念，OS 并不知道，而 M 代表内核线程。大多数现代内核将提供线程与物理处理器之间的亲和性。因此，更好的 G 到 M 的局部性会给我们更好的缓存性能。

## 6. 相关工作

在我们研究的过程中，我们参考了许多我们相信对 Go runtime 有用的论文。本章节对这些论文做一个简单介绍，并且描述这些论文是符合被我们利用的。

### 6.1 Co-scheduling

Scheduling Techniques for Concureent Systems，于 1982[11]由 John K.Ousterhout 发表，介绍了多进程在一个时间片内大规模通信的问题。本文讨论了三种不同的调度进程任务组的算法，调度进程任务组是相互通信频繁的进程组。最容易应用于 Go runtime 的算法是本文的矩阵算法。

矩阵算法将多处理器作为一个矩阵，类似于前文提过的 G 中 P 的数组。矩阵创建时，一列关联一个 P。如下图所示。行数在论文中滨给有细说，但是我们可以假设应该有足够的行数来满足算法。当一个进程任务组创建的时候，算法尝试去找到可以将整个任务组放进去的一行，这样每一个进程就可以它自己的 cell 中。如下图所示，任务组 1 和 2 放在了 row 0。任务组 3 由于太大所以放在剩下的 row 0 以及 row1 中。任务组 4 由于太小可以放在 row 0 的末端。算法将进程放在矩阵的合适位置是为了方便可以同时调度整个任务组。假设总共有 n rows，在时间片 k，在 row(k%n) 行的进程就可以调度在相应的处理上。如果一个处理器是空闲的，无论是因为在当前的任务组中，这个处理器没有进程运行，或者是当前运行的进程阻塞了，这时，这个处理器这一列的其他进程就会被调度来执行。

![屏幕快照 2018-01-07 下午 2.26.39](/Users/coyote/Desktop/ 屏幕快照 2018-01-07 下午 2.26.39.png)

如果 G 的 P 数据结构来代替处理器的话，以上算法可以用来调度同时使用一个 channel 的不同 Goroutines。这样可以大幅度减少阻塞 M 和 G 的时间花费，尽管如此，这就按要求 channel 机制的结构有大幅度的修改。

### 6.2 抢占式调度

#### 6.2.1 缓存冲突和进程

运行在同一进程的线程共享着缓存空间。
